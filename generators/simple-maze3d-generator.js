import Maze3DGenerator from './maze3d-generator.js';
import { Cell, Maze3d } from '../maze3d.js';

class SimpleMaze3dGenerator extends Maze3DGenerator {
    constructor() {
        super();
    }

    generate(stairs, rows, cols) {
        // NOTE: Create the cells
        let cells = this.createCells(stairs, rows, cols);

        // NOTE: Create the random start position
        let startPosition = this.getRandomCellPosition(stairs, rows, cols);
        let startCell = cells[startPosition.stair][startPosition.row][startPosition.col];
        startCell.content = Cell.availableContents.get("startPosition");

        // NOTE Initialize the maze
        let maze = new Maze3d(cells, startCell);

        // NOTE: Create the random goal (exit) - Commented out for the moment because we use the random path as the goal
        // TODO: Maybe Create the random path from the random entrance to the random exit generated by getRandomGoalPosition ?
        // let goalPosition = this.getRandomGoalPosition(stairs, rows, cols, startPosition);
        // let goalCell = cells[goalPosition.stair][goalPosition.row][goalPosition.col];
        // goalCell.content = Cell.availableContents.get("goal");

        /** @type {Cell} */
        let currentCell = startCell;
        // TODO: Maybe put the randomMoves to do in the parameter of the generate function?
        let randomMoves = 20;
        // NOTE: Create the random path from the random entrance to a random exit
        for (let i = 0; i < randomMoves; i++) {
            let isCurrentCellStartCell = currentCell.content === Cell.availableContents.get("startPosition");

            if (i === randomMoves - 1) {
                if (isCurrentCellStartCell === false) {
                    // NOTE: Create the goal at the last move (if it's not the start cell)
                    currentCell.content = Cell.availableContents.get("goal");
                    break;
                } else {
                    // NOTE: Add more random moves to not have the goal cell next to the start cell
                    randomMoves *= 2;
                }
            }

            // NOTE: Get the next random cell with direction
            let directionAndRandomCell = this.getRandomCellNeighbour(currentCell, maze, true, true);
            /** @type {DirectionHelper} */
            let nextCellDirection = directionAndRandomCell[0];
            /** @type {Cell} */
            let nextCell = directionAndRandomCell[1];

            // NOTE: Remove the wall between the current cell and the next cell if any
            this.updateWallsForCurrentAndNextCells(currentCell, nextCell, nextCellDirection);

            // NOTE: Update the content of the current and next cells (add elevators for example).
            this.updateContentForCurrentAndNextCells(currentCell, nextCell, nextCellDirection);

            // NOTE: Set the next cell as the current cell for the next iteration
            currentCell = nextCell;
        }

        maze.goalCell = currentCell // NOTE: The last current cell is the goal cell.
        return maze;
    }

}

export default SimpleMaze3dGenerator;
